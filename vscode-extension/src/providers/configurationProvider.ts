import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class KimiConfigurationProvider {
    private static readonly CONFIG_FILES = [
        'kimi.yaml',
        'kimi.yml',
        '.kimi.yaml',
        '.kimi.yml',
        'kimi.config.yaml',
        'kimi.config.yml'
    ];

    constructor() {
        // Register configuration change handler
        vscode.workspace.onDidChangeConfiguration(this.handleConfigurationChange.bind(this));
    }

    async openConfiguration(): Promise<void> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showWarningMessage('No workspace folder open');
            return;
        }

        const configFile = await this.findOrCreateConfigFile(workspaceFolders[0].uri.fsPath);
        
        if (configFile) {
            const document = await vscode.workspace.openTextDocument(configFile);
            await vscode.window.showTextDocument(document);
        }
    }

    private async findOrCreateConfigFile(workspacePath: string): Promise<string | undefined> {
        // Search for existing config files
        for (const configFile of KimiConfigurationProvider.CONFIG_FILES) {
            const configPath = path.join(workspacePath, configFile);
            if (fs.existsSync(configPath)) {
                return configPath;
            }
        }

        // No config file found, offer to create one
        const createNew = await vscode.window.showQuickPick(
            ['Yes', 'No'],
            { placeHolder: 'No kimi configuration found. Create a new one?' }
        );

        if (createNew === 'Yes') {
            return this.createDefaultConfig(workspacePath);
        }

        return undefined;
    }

    private async createDefaultConfig(workspacePath: string): Promise<string> {
        const configPath = path.join(workspacePath, 'kimi.yaml');
        
        const defaultConfig = `# Kimi Ecosystem Configuration
# Generated by Kimi VS Code Extension

# Audit configuration
audit:
  # Paths to include in audit
  include:
    - src/**
    - lib/**
  
  # Paths to exclude from audit
  exclude:
    - node_modules/**
    - dist/**
    - .git/**
    - "*.test.ts"
    - "*.spec.ts"
  
  # Security rules to enable
  rules:
    - sql-injection
    - xss
    - insecure-random
    - hardcoded-secrets
    - path-traversal
  
  # Severity threshold (info, low, medium, high, critical)
  severityThreshold: low

# Convergence configuration
convergence:
  # Auto-run on file changes
  autoRun: false
  
  # Convergence loop settings
  loop:
    maxIterations: 10
    timeout: 300000  # 5 minutes
    
  # Discovery settings
  discovery:
    scanDepth: 3
    followSymlinks: false
  
  # Analysis settings
  analysis:
    parallel: true
    maxWorkers: 4

# Admin configuration
admin:
  # Admin server settings
  server:
    host: localhost
    port: 8080
    
  # Authentication (if enabled)
  auth:
    enabled: false
    # token: YOUR_TOKEN_HERE

# Logging configuration
logging:
  level: info  # debug, info, warn, error
  format: json  # json, text
  output: console  # console, file, both
  
  # File logging settings (if output is file or both)
  file:
    path: ./logs/kimi.log
    maxSize: 10MB
    maxFiles: 5
    
# Extension settings
extension:
  # Show code lenses
  codeLenses: true
  
  # Show inline hints
  inlineHints: true
  
  # Auto-refresh convergence view
  autoRefresh: true
  refreshInterval: 5000
`;

        try {
            fs.writeFileSync(configPath, defaultConfig, 'utf8');
            vscode.window.showInformationMessage(`Created kimi configuration at ${configPath}`);
            return configPath;
        } catch (error) {
            vscode.window.showErrorMessage(`Failed to create configuration: ${error}`);
            throw error;
        }
    }

    private handleConfigurationChange(event: vscode.ConfigurationChangeEvent): void {
        if (event.affectsConfiguration('kimi-ecosystem')) {
            // Configuration changed, could trigger updates here
            console.log('Kimi configuration changed');
        }
    }

    getConfiguration(): vscode.WorkspaceConfiguration {
        return vscode.workspace.getConfiguration('kimi-ecosystem');
    }

    async updateConfiguration(section: string, value: unknown): Promise<void> {
        const config = this.getConfiguration();
        await config.update(section, value, vscode.ConfigurationTarget.Workspace);
    }

    dispose(): void {
        // Cleanup if needed
    }
}
