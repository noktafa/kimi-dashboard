"""
Reporting module for generating scan reports in various formats.
"""

import json
from datetime import datetime
from typing import Any, Dict, List, Optional

from .models import Finding, ScanResult, Severity


class MarkdownReporter:
    """Generates Markdown reports."""
    
    def generate(self, scan_result: ScanResult) -> str:
        """Generate a Markdown report from scan results."""
        lines = []
        
        # Header
        lines.append("# Security Audit Report")
        lines.append("")
        lines.append(f"**Target:** {scan_result.target}")
        lines.append(f"**Scan Date:** {scan_result.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}")
        if scan_result.end_time:
            duration = (scan_result.end_time - scan_result.start_time).total_seconds()
            lines.append(f"**Duration:** {duration:.2f} seconds")
        lines.append("")
        
        # Summary
        lines.append("## Summary")
        lines.append("")
        summary = scan_result.get_summary()
        lines.append("| Severity | Count |")
        lines.append("|----------|-------|")
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            count = summary.get(severity.value, 0)
            emoji = self._severity_emoji(severity)
            lines.append(f"| {emoji} {severity.value.upper()} | {count} |")
        lines.append("")
        lines.append(f"**Total Findings:** {len(scan_result.findings)}")
        lines.append("")
        
        # Findings
        if scan_result.findings:
            lines.append("## Findings")
            lines.append("")
            
            # Sort by severity
            severity_order = {s: i for i, s in enumerate([
                Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO
            ])}
            sorted_findings = sorted(
                scan_result.findings,
                key=lambda f: (severity_order.get(f.severity, 99), f.confidence.value)
            )
            
            for i, finding in enumerate(sorted_findings, 1):
                lines.append(self._format_finding(finding, i))
                lines.append("")
        else:
            lines.append("## Findings")
            lines.append("")
            lines.append("No vulnerabilities detected.")
            lines.append("")
        
        # Metadata
        if scan_result.metadata:
            lines.append("## Metadata")
            lines.append("")
            lines.append("```json")
            lines.append(json.dumps(scan_result.metadata, indent=2))
            lines.append("```")
            lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*Generated by Kimi Security Auditor*")
        
        return "\n".join(lines)
    
    def _severity_emoji(self, severity: Severity) -> str:
        """Get emoji for severity level."""
        return {
            Severity.CRITICAL: "ðŸ”´",
            Severity.HIGH: "ðŸŸ ",
            Severity.MEDIUM: "ðŸŸ¡",
            Severity.LOW: "ðŸ”µ",
            Severity.INFO: "âšª",
        }.get(severity, "âšª")
    
    def _format_finding(self, finding: Finding, index: int) -> str:
        """Format a single finding as Markdown."""
        lines = []
        
        emoji = self._severity_emoji(finding.severity)
        lines.append(f"### {index}. {emoji} {finding.title}")
        lines.append("")
        lines.append(f"**Severity:** {finding.severity.value.upper()}")
        lines.append(f"**Confidence:** {finding.confidence.value}")
        lines.append(f"**Type:** {finding.finding_type}")
        lines.append(f"**Target:** `{finding.target}`")
        lines.append("")
        
        lines.append("#### Description")
        lines.append(finding.description)
        lines.append("")
        
        if finding.evidence:
            lines.append("#### Evidence")
            lines.append(f"```\n{finding.evidence}\n```")
            lines.append("")
        
        if finding.parameter:
            lines.append(f"**Parameter:** `{finding.parameter}`")
        
        if finding.payload:
            lines.append(f"**Payload:** `{finding.payload}`")
        
        if finding.parameter or finding.payload:
            lines.append("")
        
        if finding.remediation:
            lines.append("#### Remediation")
            lines.append(finding.remediation)
            lines.append("")
        
        if finding.references:
            lines.append("#### References")
            for ref in finding.references:
                lines.append(f"- {ref}")
            lines.append("")
        
        return "\n".join(lines)


class SARIFReporter:
    """Generates SARIF (Static Analysis Results Interchange Format) reports."""
    
    SARIF_VERSION = "2.1.0"
    SCHEMA_URI = "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json"
    
    def generate(self, scan_result: ScanResult) -> str:
        """Generate a SARIF report from scan results."""
        sarif = {
            "$schema": self.SCHEMA_URI,
            "version": self.SARIF_VERSION,
            "runs": [self._create_run(scan_result)]
        }
        return json.dumps(sarif, indent=2)
    
    def _create_run(self, scan_result: ScanResult) -> Dict[str, Any]:
        """Create a SARIF run object."""
        # Create rules from finding types
        rules = {}
        for finding in scan_result.findings:
            if finding.finding_type not in rules:
                rules[finding.finding_type] = self._create_rule(finding)
        
        return {
            "tool": {
                "driver": {
                    "name": "Kimi Security Auditor",
                    "version": "0.1.0",
                    "informationUri": "https://github.com/kimi-ecosystem/kimi-security-auditor",
                    "rules": list(rules.values()),
                }
            },
            "results": [self._create_result(f, rules) for f in scan_result.findings],
            "invocations": [{
                "executionSuccessful": True,
                "startTimeUtc": scan_result.start_time.isoformat(),
                "endTimeUtc": scan_result.end_time.isoformat() if scan_result.end_time else None,
            }],
        }
    
    def _create_rule(self, finding: Finding) -> Dict[str, Any]:
        """Create a SARIF rule object."""
        return {
            "id": finding.finding_type,
            "name": finding.title,
            "shortDescription": {
                "text": finding.description[:100] + "..." if len(finding.description) > 100 else finding.description,
            },
            "fullDescription": {
                "text": finding.description,
            },
            "defaultConfiguration": {
                "level": self._severity_to_sarif_level(finding.severity),
            },
            "helpUri": finding.references[0] if finding.references else None,
            "help": {
                "text": finding.remediation or "No remediation provided.",
                "markdown": finding.remediation or "No remediation provided.",
            },
        }
    
    def _create_result(self, finding: Finding, rules: Dict[str, Any]) -> Dict[str, Any]:
        """Create a SARIF result object."""
        result = {
            "ruleId": finding.finding_type,
            "ruleIndex": list(rules.keys()).index(finding.finding_type),
            "level": self._severity_to_sarif_level(finding.severity),
            "message": {
                "text": finding.description,
            },
            "locations": [{
                "physicalLocation": {
                    "artifactLocation": {
                        "uri": finding.target,
                    },
                },
            }],
            "properties": {
                "confidence": finding.confidence.value,
                "evidence": finding.evidence,
                "parameter": finding.parameter,
                "payload": finding.payload,
            },
        }
        
        if finding.remediation:
            result["fixes"] = [{
                "description": {
                    "text": finding.remediation,
                },
            }]
        
        return result
    
    def _severity_to_sarif_level(self, severity: Severity) -> str:
        """Convert severity to SARIF level."""
        return {
            Severity.CRITICAL: "error",
            Severity.HIGH: "error",
            Severity.MEDIUM: "warning",
            Severity.LOW: "note",
            Severity.INFO: "note",
        }.get(severity, "warning")


class JSONReporter:
    """Generates JSON reports."""
    
    def generate(self, scan_result: ScanResult, indent: Optional[int] = 2) -> str:
        """Generate a JSON report from scan results."""
        return scan_result.to_json(indent=indent)


class ConsoleReporter:
    """Generates console-friendly reports using Rich."""
    
    def __init__(self):
        try:
            from rich.console import Console
            from rich.table import Table
            from rich.panel import Panel
            from rich.text import Text
            self.rich_available = True
            self.console = Console()
        except ImportError:
            self.rich_available = False
    
    def generate(self, scan_result: ScanResult) -> str:
        """Generate a console report."""
        if not self.rich_available:
            # Fallback to simple text
            return self._generate_simple_text(scan_result)
        
        # Rich output
        lines = []
        
        # Header
        lines.append(f"[bold blue]Security Audit Report[/bold blue]")
        lines.append(f"Target: {scan_result.target}")
        lines.append(f"Scan Date: {scan_result.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}")
        if scan_result.end_time:
            duration = (scan_result.end_time - scan_result.start_time).total_seconds()
            lines.append(f"Duration: {duration:.2f}s")
        lines.append("")
        
        # Summary table
        from rich.table import Table
        table = Table(title="Summary")
        table.add_column("Severity", style="bold")
        table.add_column("Count", justify="right")
        
        summary = scan_result.get_summary()
        severity_colors = {
            Severity.CRITICAL: "red",
            Severity.HIGH: "bright_red",
            Severity.MEDIUM: "yellow",
            Severity.LOW: "blue",
            Severity.INFO: "white",
        }
        
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            count = summary.get(severity.value, 0)
            color = severity_colors.get(severity, "white")
            table.add_row(f"[{color}]{severity.value.upper()}[/{color}]", str(count))
        
        self.console.print("\n".join(lines))
        self.console.print(table)
        
        # Findings
        if scan_result.findings:
            self.console.print(f"\n[bold]Findings ({len(scan_result.findings)}):[/bold]\n")
            
            severity_order = {s: i for i, s in enumerate([
                Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO
            ])}
            sorted_findings = sorted(
                scan_result.findings,
                key=lambda f: (severity_order.get(f.severity, 99), f.confidence.value)
            )
            
            for i, finding in enumerate(sorted_findings, 1):
                self._print_finding(finding, i)
        else:
            self.console.print("\n[green]No vulnerabilities detected.[/green]")
        
        return ""
    
    def _print_finding(self, finding: Finding, index: int) -> None:
        """Print a single finding."""
        from rich.panel import Panel
        from rich.text import Text
        
        severity_colors = {
            Severity.CRITICAL: "red",
            Severity.HIGH: "bright_red",
            Severity.MEDIUM: "yellow",
            Severity.LOW: "blue",
            Severity.INFO: "white",
        }
        
        color = severity_colors.get(finding.severity, "white")
        
        content = Text()
        content.append(f"Severity: ", style="bold")
        content.append(f"{finding.severity.value.upper()}\n", style=color)
        content.append(f"Confidence: ", style="bold")
        content.append(f"{finding.confidence.value}\n")
        content.append(f"Type: ", style="bold")
        content.append(f"{finding.finding_type}\n")
        content.append(f"Target: ", style="bold")
        content.append(f"{finding.target}\n\n")
        content.append(f"{finding.description}\n")
        
        if finding.evidence:
            content.append(f"\nEvidence: ", style="bold")
            content.append(f"{finding.evidence}")
        
        panel = Panel(
            content,
            title=f"{index}. {finding.title}",
            border_style=color,
        )
        
        self.console.print(panel)
    
    def _generate_simple_text(self, scan_result: ScanResult) -> str:
        """Generate simple text report when Rich is not available."""
        lines = []
        
        lines.append("=" * 60)
        lines.append("SECURITY AUDIT REPORT")
        lines.append("=" * 60)
        lines.append(f"Target: {scan_result.target}")
        lines.append(f"Scan Date: {scan_result.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')}")
        lines.append("")
        
        # Summary
        lines.append("SUMMARY")
        lines.append("-" * 40)
        summary = scan_result.get_summary()
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            count = summary.get(severity.value, 0)
            lines.append(f"  {severity.value.upper()}: {count}")
        lines.append(f"  TOTAL: {len(scan_result.findings)}")
        lines.append("")
        
        # Findings
        if scan_result.findings:
            lines.append("FINDINGS")
            lines.append("-" * 40)
            
            for i, finding in enumerate(scan_result.findings, 1):
                lines.append(f"\n{i}. [{finding.severity.value.upper()}] {finding.title}")
                lines.append(f"   Type: {finding.finding_type}")
                lines.append(f"   Target: {finding.target}")
                lines.append(f"   Description: {finding.description}")
                if finding.evidence:
                    lines.append(f"   Evidence: {finding.evidence}")
                if finding.remediation:
                    lines.append(f"   Remediation: {finding.remediation}")
        else:
            lines.append("No vulnerabilities detected.")
        
        return "\n".join(lines)


def save_report(scan_result: ScanResult, filepath: str, format: str = "auto") -> None:
    """
    Save a report to a file.
    
    Args:
        scan_result: The scan results to report
        filepath: Path to save the report
        format: Report format (auto, markdown, md, sarif, json, console)
               If 'auto', inferred from file extension
    """
    # Auto-detect format from extension
    if format == "auto":
        if filepath.endswith('.md'):
            format = "markdown"
        elif filepath.endswith('.sarif'):
            format = "sarif"
        elif filepath.endswith('.json'):
            format = "json"
        else:
            format = "markdown"
    
    # Generate report
    if format in ("markdown", "md"):
        reporter = MarkdownReporter()
    elif format == "sarif":
        reporter = SARIFReporter()
    elif format == "json":
        reporter = JSONReporter()
    elif format == "console":
        reporter = ConsoleReporter()
    else:
        raise ValueError(f"Unknown format: {format}")
    
    content = reporter.generate(scan_result)
    
    # Write to file
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
